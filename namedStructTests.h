/* Testing structs generated by namedstructpy */
// Code generated by namedstruct.py

#ifndef __NAMEDSTRUCTTEST__
#define __NAMEDSTRUCTTEST__
#include <stdint.h>
#include <namedstruct/bits.h>

namespace namedStructTest {
    
    // *** constants *****************************
    static constexpr int32_t THREE = 3;
    
    
    // *** forward declarations ******************
    struct testStruct0;
    struct testStruct1;
    struct testStruct2;
    struct testNestedStruct0;
    struct testStruct3;
    struct testStruct4;
    struct testStruct5;
    struct testStruct6;
    struct testStruct7;
    struct testStruct8;
    struct testStruct9;
    struct testStruct10;
    struct testStruct11;
    struct testNestedStruct1;
    struct testStruct12;
    struct testNestedStruct2;
    struct testStruct13;
    struct testStruct14;
    struct testStruct15;
    struct testStruct16;
    struct elementStruct0;
    struct testStruct17;
    struct elementStruct1;
    struct testStruct18;
    struct elementStruct2;
    struct testStruct19;
    struct testStruct20;
    struct testStruct21;
    struct testStruct22;
    struct testStruct23;
    struct elementStruct3;
    struct testStruct24;
    struct testStruct25;
    struct charRefArray;
    struct testStruct26;
    struct testStruct27;
    struct voidRefArray;
    struct testStruct28;
    struct elementStruct4;
    struct elementStruct4RefArray;
    struct testStruct29;
    struct charRef8Array;
    struct testStruct30;
    struct int32_tRef16Array;
    struct testStruct31;
    struct charSize4RefArray;
    struct testStruct32;
    struct charSize2RefArray;
    struct charSize2RefArrayRef16Array;
    struct charSize2RefArrayRef16ArrayRefArray;
    struct testStruct33;
    struct bitField1;
    struct bitField2;
    struct testStruct34;
    struct timeBitField;
    struct testStruct35;
    struct testNestedStruct3;
    struct testNestedStruct4;
    struct testNestedStruct5;
    struct testNestedStruct6;
    struct testStruct36;
    struct bitField2000;
    struct testStruct37;
    struct BitBitArray;
    struct testStruct38;
    struct PairBitArray;
    struct testStruct39;
    struct ABFooBitArray;
    struct testStruct40;
    struct VarBitArrayA;
    struct testStruct41A;
    struct VarBitArrayB;
    struct testStruct41B;
    struct VarBitArrayC;
    struct testStruct41C;
    enum class GenderEnum : uint8_t;
    enum class PartyEnum : int32_t;
    enum class NationEnum : char;
    struct testStruct42;
    struct bitField43;
    struct testStruct43;
    struct BitField44;
    struct testStruct44;
    enum class YesEnum : uint16_t;
    enum class NoEnum : int32_t;
    struct BitField45;
    struct testStruct45;
    struct BitField46;
    struct testStruct46;
    struct BitField47;
    struct testStruct47;
    struct Aardvark;
    struct Wombat;
    struct Zebra;
    struct SubWalrus;
    struct Walrus;
    struct Baboon;
    struct testPackOrder;
    struct testMatrix;
    
    
    // *** type declarations *********************
    typedef struct __attribute__((packed)) testStruct0 {
    } testStruct0;
    
    
    typedef struct __attribute__((packed)) testStruct1 {
        int32_t bla;
        
                    bool operator==(const testStruct1& other) const {
                        return bla == other.bla;
                    }
                    
                    bool operator!=(const testStruct1& other) const {
                        return not (*this == other);
                    }
                } testStruct1;
    
    
    typedef struct __attribute__((packed)) testStruct2 {
        int8_t woot;
        
                    bool operator==(const testStruct2& other) const {
                        return woot == other.woot;
                    }
                    
                    bool operator!=(const testStruct2& other) const {
                        return not (*this == other);
                    }
                } testStruct2;
    
    
    typedef struct __attribute__((packed)) testNestedStruct0 {
        int8_t bla;
        
                    bool operator==(const testNestedStruct0& other) const {
                        return bla == other.bla;
                    }
                    
                    bool operator!=(const testNestedStruct0& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct0;
    
    
    typedef struct __attribute__((packed)) testStruct3 {
        int8_t  four;
        int8_t  paddingByte0;
        int8_t  paddingByte1;
        int8_t  paddingByte2;
        int32_t nestedMemberByteOffset;
    
        /** Returns testNestedStruct0-pointer to member nestedMember.
         *  If nestedMember is null/void then the result is undefined. */
        inline testNestedStruct0* getNestedMember() const {
            return (testNestedStruct0*)(uintptr_t(this)+this->nestedMemberByteOffset);
        }
    } testStruct3;
    
    
    typedef struct __attribute__((packed)) testStruct4 {
        int32_t helloByteOffset;
    
        /** Returns char-pointer to member hello.
         *  If hello is null/void then the result is undefined. */
        inline char* getHello() const {
            return (char*)(uintptr_t(this)+this->helloByteOffset);
        }
    } testStruct4;
    
    
    typedef struct __attribute__((packed)) testStruct5 {
        int32_t unicodeStringByteOffset;
    
        /** Returns char-pointer to member unicodeString.
         *  If unicodeString is null/void then the result is undefined. */
        inline char* getUnicodeString() const {
            return (char*)(uintptr_t(this)+this->unicodeStringByteOffset);
        }
    } testStruct5;
    
    
    typedef struct __attribute__((packed)) testStruct6 {
        int32_t myBlobByteOffset;
    
        /** Returns char-pointer to member myBlob.
         *  If myBlob is null/void then the result is undefined. */
        inline char* getMyBlob() const {
            return (char*)(uintptr_t(this)+this->myBlobByteOffset);
        }
    } testStruct6;
    
    
    typedef struct __attribute__((packed)) testStruct7 {
        int8_t   anInt8;
        int8_t   paddingByte0;
        int8_t   paddingByte1;
        int8_t   paddingByte2;
        int32_t  anInt32;
        uint32_t anUint32;
        int32_t  aStringByteOffset;
        int32_t  aBlobByteOffset;
    
        /** Returns char-pointer to member aString.
         *  If aString is null/void then the result is undefined. */
        inline char* getAString() const {
            return (char*)(uintptr_t(this)+this->aStringByteOffset);
        }
        
        /** Returns char-pointer to member aBlob.
         *  If aBlob is null/void then the result is undefined. */
        inline char* getABlob() const {
            return (char*)(uintptr_t(this)+this->aBlobByteOffset);
        }
    } testStruct7;
    
    
    typedef struct __attribute__((packed)) testStruct8 {
        int32_t longBlobByteOffset;
    
        /** Returns char-pointer to member longBlob.
         *  If longBlob is null/void then the result is undefined. */
        inline char* getLongBlob() const {
            return (char*)(uintptr_t(this)+this->longBlobByteOffset);
        }
    } testStruct8;
    
    
    typedef struct __attribute__((packed)) testStruct9 {
        int32_t longStringByteOffset;
    
        /** Returns char-pointer to member longString.
         *  If longString is null/void then the result is undefined. */
        inline char* getLongString() const {
            return (char*)(uintptr_t(this)+this->longStringByteOffset);
        }
    } testStruct9;
    
    
    typedef struct __attribute__((packed)) testStruct10 {
        static constexpr int32_t     EVERYTHING = 43;
        static constexpr int32_t     FOO = 0;
        static constexpr char        LABEL[] = "this is a label";
        static constexpr char        QUOTE[] = "\"";
        static constexpr int32_t     TEST_CONSTANT_1 = 42;
        static constexpr char        TEST_CONSTANT_2[] = "something";
        static constexpr int32_t     LUCKY_NUMBERS[] = {2, 3, 5, 7};
        static constexpr int32_t     IDENTITY[2][2] = {{1, 0}, {0, 1}};
        static constexpr const char* GREAT_LAKES[] = {"Superior", "Michigan", "Huron", "Erie", "Ontario"};
    } testStruct10;
    
    
    typedef struct __attribute__((packed)) testStruct11 {
        int32_t value;
        int32_t nextByteOffset;
    
        /** Returns testStruct11-pointer to member next.
         *  If next is null/void then the result is undefined. */
        inline testStruct11* getNext() const {
            return (testStruct11*)(uintptr_t(this)+this->nextByteOffset);
        }
    } testStruct11;
    
    
    typedef struct __attribute__((packed)) testNestedStruct1 {
        int8_t anotherValue;
        
                    bool operator==(const testNestedStruct1& other) const {
                        return anotherValue == other.anotherValue;
                    }
                    
                    bool operator!=(const testNestedStruct1& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct1;
    
    
    typedef struct __attribute__((packed)) testStruct12 {
        int32_t anotherStructByteOffset;
        int8_t  aValue;
    
        /** Returns testNestedStruct1-pointer to member anotherStruct.
         *  If anotherStruct is null/void then the result is undefined. */
        inline testNestedStruct1* getAnotherStruct() const {
            return (testNestedStruct1*)(uintptr_t(this)+this->anotherStructByteOffset);
        }
    } testStruct12;
    
    
    typedef struct __attribute__((packed)) testNestedStruct2 {
        int32_t y;
        
                    bool operator==(const testNestedStruct2& other) const {
                        return y == other.y;
                    }
                    
                    bool operator!=(const testNestedStruct2& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct2;
    
    
    typedef struct __attribute__((packed)) testStruct13 {
        int8_t            x;
        int8_t            paddingByte0;
        int8_t            paddingByte1;
        int8_t            paddingByte2;
        testNestedStruct2 immediateStruct;
        
                    bool operator==(const testStruct13& other) const {
                        return (    x == other.x
                    and paddingByte0 == other.paddingByte0
                    and paddingByte1 == other.paddingByte1
                    and paddingByte2 == other.paddingByte2
                    and immediateStruct == other.immediateStruct);
                    }
                    
                    bool operator!=(const testStruct13& other) const {
                        return not (*this == other);
                    }
                } testStruct13;
    
    
    typedef struct __attribute__((packed)) testStruct14 {
        int32_t number;
        int32_t stringByteOffset;
        int32_t refByteOffset;
    
        /** Returns char-pointer to member string.
         *  If string is null/void then the result is undefined. */
        inline char* getString() const {
            return (char*)(uintptr_t(this)+this->stringByteOffset);
        }
        
        /** Returns void-pointer to member ref.
         *  If ref is null/void then the result is undefined. */
        inline void* getRef() const {
            return (void*)(uintptr_t(this)+this->refByteOffset);
        }
    } testStruct14;
    
    
    typedef struct __attribute__((packed)) testStruct15 {
        char immedateString[];
    } testStruct15;
    
    
    typedef struct __attribute__((packed)) testStruct16 {
        char fixedString[30];
        char nonFixedString[];
    } testStruct16;
    
    
    typedef struct __attribute__((packed)) elementStruct0 {
        int32_t nameByteOffset;
        int8_t  x;
        int8_t  paddingByte0;
        int8_t  paddingByte1;
        int8_t  paddingByte2;
    
        /** Returns char-pointer to member name.
         *  If name is null/void then the result is undefined. */
        inline char* getName() const {
            return (char*)(uintptr_t(this)+this->nameByteOffset);
        }
    } elementStruct0;
    
    
    typedef struct __attribute__((packed)) testStruct17 {
        int32_t structArrayByteOffset;
    
        /** Returns elementStruct0-pointer to member structArray.
         *  If structArray is null/void then the result is undefined. */
        inline elementStruct0* getStructArray() const {
            return (elementStruct0*)(uintptr_t(this)+this->structArrayByteOffset);
        }
    } testStruct17;
    
    
    typedef struct __attribute__((packed)) elementStruct1 {
        int8_t foo;
        int8_t paddingByte0;
        int8_t paddingByte1;
        int8_t paddingByte2;
        
                    bool operator==(const elementStruct1& other) const {
                        return (    foo == other.foo
                    and paddingByte0 == other.paddingByte0
                    and paddingByte1 == other.paddingByte1
                    and paddingByte2 == other.paddingByte2);
                    }
                    
                    bool operator!=(const elementStruct1& other) const {
                        return not (*this == other);
                    }
                } elementStruct1;
    
    
    typedef struct __attribute__((packed)) testStruct18 {
        elementStruct1 structArray[3];
        int32_t        x;
    } testStruct18;
    
    
    typedef struct __attribute__((packed)) elementStruct2 {
        int32_t anameByteOffset;
    
        /** Returns char-pointer to member aname.
         *  If aname is null/void then the result is undefined. */
        inline char* getAname() const {
            return (char*)(uintptr_t(this)+this->anameByteOffset);
        }
    } elementStruct2;
    
    
    typedef struct __attribute__((packed)) testStruct19 {
        elementStruct2 structArray[2];
        int32_t        xyz;
    } testStruct19;
    
    
    typedef struct __attribute__((packed)) testStruct20 {
        char aChar;
        char bChar;
        char cChar;
        char dChar;
        
                    bool operator==(const testStruct20& other) const {
                        return (    aChar == other.aChar
                    and bChar == other.bChar
                    and cChar == other.cChar
                    and dChar == other.dChar);
                    }
                    
                    bool operator!=(const testStruct20& other) const {
                        return not (*this == other);
                    }
                } testStruct20;
    
    
    typedef struct __attribute__((packed)) testStruct21 {
        static constexpr char a = '!';
        static constexpr char b = '\'';
        static constexpr char c = '\"';
        static constexpr char d = '\n';
        static constexpr char e = '\x00';
    } testStruct21;
    
    
    typedef struct __attribute__((packed)) testStruct22 {
        char magic[4];
        char end;
    } testStruct22;
    
    
    typedef struct __attribute__((packed)) testStruct23 {
        int32_t noStringByteOffset;
    
        /** Returns char-pointer to member noString.
         *  If noString is null/void then the result is undefined. */
        inline char* getNoString() const {
            return (char*)(uintptr_t(this)+this->noStringByteOffset);
        }
    } testStruct23;
    
    
    typedef struct __attribute__((packed)) elementStruct3 {
        int32_t maybeStringByteOffset;
    
        /** Returns char-pointer to member maybeString.
         *  If maybeString is null/void then the result is undefined. */
        inline char* getMaybeString() const {
            return (char*)(uintptr_t(this)+this->maybeStringByteOffset);
        }
    } elementStruct3;
    
    
    typedef struct __attribute__((packed)) testStruct24 {
        elementStruct3 structArray[2];
    } testStruct24;
    
    
    typedef struct __attribute__((packed)) testStruct25 {
        uint8_t aByteOffset;
        uint8_t bByteOffset;
        int16_t cByteOffset;
        int32_t dByteOffset;
    
        /** Returns char-pointer to member a.
         *  If a is null/void then the result is undefined. */
        inline char* getA() const {
            return (char*)(uintptr_t(this)+this->aByteOffset);
        }
        
        /** Returns char-pointer to member b.
         *  If b is null/void then the result is undefined. */
        inline char* getB() const {
            return (char*)(uintptr_t(this)+this->bByteOffset);
        }
        
        /** Returns char-pointer to member c.
         *  If c is null/void then the result is undefined. */
        inline char* getC() const {
            return (char*)(uintptr_t(this)+this->cByteOffset);
        }
        
        /** Returns char-pointer to member d.
         *  If d is null/void then the result is undefined. */
        inline char* getD() const {
            return (char*)(uintptr_t(this)+this->dByteOffset);
        }
    } testStruct25;
    
    
    typedef struct __attribute__((packed)) charRefArray {
        int32_t elementByteOffsets[];
        
        /** Returns char-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline char* get(const int index) const {
            return (char*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charRefArray;
    
    
    typedef struct __attribute__((packed)) testStruct26 {
        int32_t refArrayByteOffset;
    
        /** Returns charRefArray-pointer to member refArray.
         *  If refArray is null/void then the result is undefined. */
        inline charRefArray* getRefArray() const {
            return (charRefArray*)(uintptr_t(this)+this->refArrayByteOffset);
        }
    } testStruct26;
    
    
    typedef struct __attribute__((packed)) testStruct27 {
        int32_t bRefArrayByteOffset;
    
        /** Returns charRefArray-pointer to member bRefArray.
         *  If bRefArray is null/void then the result is undefined. */
        inline charRefArray* getBRefArray() const {
            return (charRefArray*)(uintptr_t(this)+this->bRefArrayByteOffset);
        }
    } testStruct27;
    
    
    typedef struct __attribute__((packed)) voidRefArray {
        int32_t elementByteOffsets[];
        
        /** Returns void-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline void* get(const int index) const {
            return (void*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } voidRefArray;
    
    
    typedef struct __attribute__((packed)) testStruct28 {
        int32_t cRefArrayByteOffset;
    
        /** Returns voidRefArray-pointer to member cRefArray.
         *  If cRefArray is null/void then the result is undefined. */
        inline voidRefArray* getCRefArray() const {
            return (voidRefArray*)(uintptr_t(this)+this->cRefArrayByteOffset);
        }
    } testStruct28;
    
    
    typedef struct __attribute__((packed)) elementStruct4 {
        int32_t age;
        char    name[];
    } elementStruct4;
    
    
    typedef struct __attribute__((packed)) elementStruct4RefArray {
        int32_t elementByteOffsets[];
        
        /** Returns elementStruct4-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline elementStruct4* get(const int index) const {
            return (elementStruct4*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } elementStruct4RefArray;
    
    
    typedef struct __attribute__((packed)) testStruct29 {
        int32_t rArrayByteOffset;
    
        /** Returns elementStruct4RefArray-pointer to member rArray.
         *  If rArray is null/void then the result is undefined. */
        inline elementStruct4RefArray* getRArray() const {
            return (elementStruct4RefArray*)(uintptr_t(this)+this->rArrayByteOffset);
        }
    } testStruct29;
    
    
    typedef struct __attribute__((packed)) charRef8Array {
        uint8_t elementByteOffsets[];
        
        /** Returns char-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline char* get(const int index) const {
            return (char*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charRef8Array;
    
    
    typedef struct __attribute__((packed)) testStruct30 {
        int32_t stringsByteOffset;
    
        /** Returns charRef8Array-pointer to member strings.
         *  If strings is null/void then the result is undefined. */
        inline charRef8Array* getStrings() const {
            return (charRef8Array*)(uintptr_t(this)+this->stringsByteOffset);
        }
    } testStruct30;
    
    
    typedef struct __attribute__((packed)) int32_tRef16Array {
        int16_t elementByteOffsets[];
        
        /** Returns int32_t-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline int32_t* get(const int index) const {
            return (int32_t*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } int32_tRef16Array;
    
    
    typedef struct __attribute__((packed)) testStruct31 {
        int32_t arrayByteOffset;
        int32_t sizesByteOffset;
    
        /** Returns int32_tRef16Array-pointer to member array.
         *  If array is null/void then the result is undefined. */
        inline int32_tRef16Array* getArray() const {
            return (int32_tRef16Array*)(uintptr_t(this)+this->arrayByteOffset);
        }
        
        /** Returns int32_t-pointer to member sizes.
         *  If sizes is null/void then the result is undefined. */
        inline int32_t* getSizes() const {
            return (int32_t*)(uintptr_t(this)+this->sizesByteOffset);
        }
    } testStruct31;
    
    
    typedef struct __attribute__((packed)) charSize4RefArray {
        int32_t elementByteOffsets[4];
        
        /** Returns char-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline char* get(const int index) const {
            return (char*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charSize4RefArray;
    
    
    typedef struct __attribute__((packed)) testStruct32 {
        charSize4RefArray fixedArray;
        int32_t           terminal;
    } testStruct32;
    
    
    typedef struct __attribute__((packed)) charSize2RefArray {
        int32_t elementByteOffsets[2];
        
        /** Returns char-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline char* get(const int index) const {
            return (char*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charSize2RefArray;
    
    
    typedef struct __attribute__((packed)) charSize2RefArrayRef16Array {
        int16_t elementByteOffsets[];
        
        /** Returns charSize2RefArray-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline charSize2RefArray* get(const int index) const {
            return (charSize2RefArray*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charSize2RefArrayRef16Array;
    
    
    typedef struct __attribute__((packed)) charSize2RefArrayRef16ArrayRefArray {
        int32_t elementByteOffsets[];
        
        /** Returns charSize2RefArrayRef16Array-pointer to the element at the given index.
         *  If the element at the given index is null/void, then the result is undefined. */
        inline charSize2RefArrayRef16Array* get(const int index) const {
            return (charSize2RefArrayRef16Array*)(uintptr_t(this)+this->elementByteOffsets[index]);
        }
    } charSize2RefArrayRef16ArrayRefArray;
    
    
    typedef struct __attribute__((packed)) testStruct33 {
        int32_t refsrefsrefsByteOffset;
        int32_t terminal;
    
        /** Returns charSize2RefArrayRef16ArrayRefArray-pointer to member refsrefsrefs.
         *  If refsrefsrefs is null/void then the result is undefined. */
        inline charSize2RefArrayRef16ArrayRefArray* getRefsrefsrefs() const {
            return (charSize2RefArrayRef16ArrayRefArray*)(uintptr_t(this)+this->refsrefsrefsByteOffset);
        }
    } testStruct33;
    
    
    typedef struct __attribute__((packed)) bitField1 {
        uint8_t bits;
        /**  1 bit  */ inline int getAFlag()  const { auto v = (bits >>  0) & 0x1;  return static_cast<int>(v); }
        /**  1 bit  */ inline int getBFlag()  const { auto v = (bits >>  1) & 0x1;  return static_cast<int>(v); }
        /**  1 bit  */ inline int getCFlag()  const { auto v = (bits >>  2) & 0x1;  return static_cast<int>(v); }
        /**  2 bits */ inline int getValues() const { auto v = (bits >>  3) & 0x3;  return static_cast<int>(v); }
        
        inline void setAFlag(int v) {
            uint8_t intValue = static_cast<uint8_t>(v);
            uint8_t bitValue = intValue;
            bits = (bits & ~(0x1 <<  0)) | ((bitValue & 0x1) <<  0);
        }
        
        inline void setBFlag(int v) {
            uint8_t intValue = static_cast<uint8_t>(v);
            uint8_t bitValue = intValue;
            bits = (bits & ~(0x1 <<  1)) | ((bitValue & 0x1) <<  1);
        }
        
        inline void setCFlag(int v) {
            uint8_t intValue = static_cast<uint8_t>(v);
            uint8_t bitValue = intValue;
            bits = (bits & ~(0x1 <<  2)) | ((bitValue & 0x1) <<  2);
        }
        
        inline void setValues(int v) {
            uint8_t intValue = static_cast<uint8_t>(v);
            uint8_t bitValue = intValue;
            bits = (bits & ~(0x3 <<  3)) | ((bitValue & 0x3) <<  3);
        }
        
        inline bool operator==(const bitField1 other) const {
            return (bits & 0x1F) == (other.bits & 0x1F);
        }
        
        inline bool operator!=(const bitField1 other) const {
            return not (*this == other);
        }
    } bitField1;
    
    
    
    typedef struct __attribute__((packed)) bitField2 {
        uint16_t bits;
        /**  1 bit  */ inline int getAFlag() const { auto v = (bits >>  0) & 0x01;  return static_cast<int>(v); }
        /**  7 bits */ inline int getB()     const { auto v = (bits >>  1) & 0x7f;  return static_cast<int>(v); }
        /**  3 bits */ inline int getC()     const { auto v = (bits >>  8) & 0x07;  return static_cast<int>(v); }
        /**  5 bits */ inline int getD()     const { auto v = (bits >> 11) & 0x1f;  return static_cast<int>(v); }
        
        inline void setAFlag(int v) {
            uint16_t intValue = static_cast<uint16_t>(v);
            uint16_t bitValue = intValue;
            bits = (bits & ~(0x01 <<  0)) | ((bitValue & 0x01) <<  0);
        }
        
        inline void setB(int v) {
            uint16_t intValue = static_cast<uint16_t>(v);
            uint16_t bitValue = intValue;
            bits = (bits & ~(0x7f <<  1)) | ((bitValue & 0x7f) <<  1);
        }
        
        inline void setC(int v) {
            uint16_t intValue = static_cast<uint16_t>(v);
            uint16_t bitValue = intValue;
            bits = (bits & ~(0x07 <<  8)) | ((bitValue & 0x07) <<  8);
        }
        
        inline void setD(int v) {
            uint16_t intValue = static_cast<uint16_t>(v);
            uint16_t bitValue = intValue;
            bits = (bits & ~(0x1f << 11)) | ((bitValue & 0x1f) << 11);
        }
        
        inline bool operator==(const bitField2 other) const {
            return (bits & 0xFFFF) == (other.bits & 0xFFFF);
        }
        
        inline bool operator!=(const bitField2 other) const {
            return not (*this == other);
        }
    } bitField2;
    
    
    
    typedef struct __attribute__((packed)) testStruct34 {
        bitField1 flags;
        int8_t    paddingByte0;
        bitField2 smallInts;
        int32_t   terminal;
        
                    bool operator==(const testStruct34& other) const {
                        return (    flags == other.flags
                    and paddingByte0 == other.paddingByte0
                    and smallInts == other.smallInts
                    and terminal == other.terminal);
                    }
                    
                    bool operator!=(const testStruct34& other) const {
                        return not (*this == other);
                    }
                } testStruct34;
    
    
    typedef struct __attribute__((packed)) timeBitField {
        uint32_t bits;
        /** 11 bits */ inline int getYear()   const { auto v = (bits >>  0) & 0x7ff;  return static_cast<int>(v); }
        /**  4 bits */ inline int getMonth()  const { auto v = (bits >> 11) & 0x00f;  return static_cast<int>(v); }
        /**  5 bits */ inline int getDay()    const { auto v = (bits >> 15) & 0x01f;  return static_cast<int>(v); }
        /**  5 bits */ inline int getHour()   const { auto v = (bits >> 20) & 0x01f;  return static_cast<int>(v); }
        /**  6 bits */ inline int getMinute() const { auto v = (bits >> 25) & 0x03f;  return static_cast<int>(v); }
        
        inline void setYear(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x7ff <<  0)) | ((bitValue & 0x7ff) <<  0);
        }
        
        inline void setMonth(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x00f << 11)) | ((bitValue & 0x00f) << 11);
        }
        
        inline void setDay(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x01f << 15)) | ((bitValue & 0x01f) << 15);
        }
        
        inline void setHour(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x01f << 20)) | ((bitValue & 0x01f) << 20);
        }
        
        inline void setMinute(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x03f << 25)) | ((bitValue & 0x03f) << 25);
        }
        
        inline bool operator==(const timeBitField other) const {
            return (bits & 0x7FFFFFFF) == (other.bits & 0x7FFFFFFF);
        }
        
        inline bool operator!=(const timeBitField other) const {
            return not (*this == other);
        }
    } timeBitField;
    
    
    
    typedef struct __attribute__((packed)) testStruct35 {
        int32_t datesByteOffset;
    
        /** Returns timeBitField-pointer to member dates.
         *  If dates is null/void then the result is undefined. */
        inline timeBitField* getDates() const {
            return (timeBitField*)(uintptr_t(this)+this->datesByteOffset);
        }
    } testStruct35;
    
    
    typedef struct __attribute__((packed)) testNestedStruct3 {
        uint8_t x;
        uint8_t y;
        
                    bool operator==(const testNestedStruct3& other) const {
                        return (    x == other.x
                    and y == other.y);
                    }
                    
                    bool operator!=(const testNestedStruct3& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct3;
    
    
    typedef struct __attribute__((packed)) testNestedStruct4 {
        uint16_t x;
        
                    bool operator==(const testNestedStruct4& other) const {
                        return x == other.x;
                    }
                    
                    bool operator!=(const testNestedStruct4& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct4;
    
    
    typedef struct __attribute__((packed)) testNestedStruct5 {
        uint32_t x;
        
                    bool operator==(const testNestedStruct5& other) const {
                        return x == other.x;
                    }
                    
                    bool operator!=(const testNestedStruct5& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct5;
    
    
    typedef struct __attribute__((packed)) testNestedStruct6 {
        uint64_t x;
        uint64_t y;
        
                    bool operator==(const testNestedStruct6& other) const {
                        return (    x == other.x
                    and y == other.y);
                    }
                    
                    bool operator!=(const testNestedStruct6& other) const {
                        return not (*this == other);
                    }
                } testNestedStruct6;
    
    
    typedef struct __attribute__((packed)) testStruct36 {
        int32_t s0ByteOffset;
        int32_t s1ByteOffset;
        int32_t s2ByteOffset;
        int32_t s3ByteOffset;
        uint8_t terminal;
    
        /** Returns testNestedStruct3-pointer to member s0.
         *  If s0 is null/void then the result is undefined. */
        inline testNestedStruct3* getS0() const {
            return (testNestedStruct3*)(uintptr_t(this)+this->s0ByteOffset);
        }
        
        /** Returns testNestedStruct4-pointer to member s1.
         *  If s1 is null/void then the result is undefined. */
        inline testNestedStruct4* getS1() const {
            return (testNestedStruct4*)(uintptr_t(this)+this->s1ByteOffset);
        }
        
        /** Returns testNestedStruct5-pointer to member s2.
         *  If s2 is null/void then the result is undefined. */
        inline testNestedStruct5* getS2() const {
            return (testNestedStruct5*)(uintptr_t(this)+this->s2ByteOffset);
        }
        
        /** Returns testNestedStruct6-pointer to member s3.
         *  If s3 is null/void then the result is undefined. */
        inline testNestedStruct6* getS3() const {
            return (testNestedStruct6*)(uintptr_t(this)+this->s3ByteOffset);
        }
    } testStruct36;
    
    
    typedef struct __attribute__((packed)) bitField2000 {
        uint32_t bits;
        /** 13 bits */ inline int getAField() const { auto v = (bits >>  0) & 0x1fff;  return static_cast<int>(v); }
        
        inline void setAField(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x1fff <<  0)) | ((bitValue & 0x1fff) <<  0);
        }
        
        inline bool operator==(const bitField2000 other) const {
            return (bits & 0x1FFF) == (other.bits & 0x1FFF);
        }
        
        inline bool operator!=(const bitField2000 other) const {
            return not (*this == other);
        }
    } bitField2000;
    
    
    
    typedef struct __attribute__((packed)) testStruct37 {
        int32_t stringRefByteOffset;
        int32_t bitFieldReferenceByteOffset;
        int16_t int8ArrayRefByteOffset;
        uint8_t uint8RefByteOffset;
    
        /** Returns char-pointer to member stringRef.
         *  If stringRef is null/void then the result is undefined. */
        inline char* getStringRef() const {
            return (char*)(uintptr_t(this)+this->stringRefByteOffset);
        }
        
        /** Returns bitField2000-pointer to member bitFieldReference.
         *  If bitFieldReference is null/void then the result is undefined. */
        inline bitField2000* getBitFieldReference() const {
            return (bitField2000*)(uintptr_t(this)+this->bitFieldReferenceByteOffset);
        }
        
        /** Returns int8_t-pointer to member int8ArrayRef.
         *  If int8ArrayRef is null/void then the result is undefined. */
        inline int8_t* getInt8ArrayRef() const {
            return (int8_t*)(uintptr_t(this)+this->int8ArrayRefByteOffset);
        }
        
        /** Returns int8_t-pointer to member uint8Ref.
         *  If uint8Ref is null/void then the result is undefined. */
        inline int8_t* getUint8Ref() const {
            return (int8_t*)(uintptr_t(this)+this->uint8RefByteOffset);
        }
    } testStruct37;
    
    
    typedef struct __attribute__((packed)) BitBitArray {
        uint16_t bitFieldArrayEntryBits;
        uint16_t bitBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field bit at the given index, assuming it is present */
        inline int getBitBitOffset(int index) const {
            return bitBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field bit at the given index, assuming it is present */
        inline int hasBit() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field bit, assuming it is present */
        inline int getBitNumBits() const {
            return endOffset - bitBitOffset;
        }
        
        /** returns the value of the field bit at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getBit(int index) const {
            const int bitOffset = bitBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bitBitOffset);
        }
        
        /** returns the value of the field bit at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBitOrDefault(int index, int defaultValue = 0) const {
            return hasBit() ? getBit(index) : defaultValue;
        }
    } BitBitArray;
    
    
    typedef struct __attribute__((packed)) testStruct38 {
        int32_t bitArrayByteOffset;
    
        /** Returns BitBitArray-pointer to member bitArray.
         *  If bitArray is null/void then the result is undefined. */
        inline BitBitArray* getBitArray() const {
            return (BitBitArray*)(uintptr_t(this)+this->bitArrayByteOffset);
        }
    } testStruct38;
    
    
    typedef struct __attribute__((packed)) PairBitArray {
        uint16_t bitFieldArrayEntryBits;
        uint16_t aBitOffset;
        uint16_t bBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int getABitOffset(int index) const {
            return aBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int hasA() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field a, assuming it is present */
        inline int getANumBits() const {
            return bBitOffset - aBitOffset;
        }
        
        /** returns the value of the field a at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getA(int index) const {
            const int bitOffset = aBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = bBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-aBitOffset);
        }
        
        /** returns the value of the field a at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getAOrDefault(int index, int defaultValue = 0) const {
            return hasA() ? getA(index) : defaultValue;
        }    
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int getBBitOffset(int index) const {
            return bBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int hasB() const {
            return getNumFields() > 1;
        }
        
        /** returns the number of bits used by field b, assuming it is present */
        inline int getBNumBits() const {
            return endOffset - bBitOffset;
        }
        
        /** returns the value of the field b at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getB(int index) const {
            const int bitOffset = bBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bBitOffset);
        }
        
        /** returns the value of the field b at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBOrDefault(int index, int defaultValue = 0) const {
            return hasB() ? getB(index) : defaultValue;
        }
    } PairBitArray;
    
    
    typedef struct __attribute__((packed)) testStruct39 {
        int32_t pairArrayByteOffset;
    
        /** Returns PairBitArray-pointer to member pairArray.
         *  If pairArray is null/void then the result is undefined. */
        inline PairBitArray* getPairArray() const {
            return (PairBitArray*)(uintptr_t(this)+this->pairArrayByteOffset);
        }
    } testStruct39;
    
    
    typedef struct __attribute__((packed)) ABFooBitArray {
        uint16_t bitFieldArrayEntryBits;
        uint16_t aBitOffset;
        uint16_t bBitOffset;
        uint16_t fooBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int getABitOffset(int index) const {
            return aBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int hasA() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field a, assuming it is present */
        inline int getANumBits() const {
            return bBitOffset - aBitOffset;
        }
        
        /** returns the value of the field a at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getA(int index) const {
            const int bitOffset = aBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = bBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-aBitOffset);
        }
        
        /** returns the value of the field a at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getAOrDefault(int index, int defaultValue = 0) const {
            return hasA() ? getA(index) : defaultValue;
        }    
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int getBBitOffset(int index) const {
            return bBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int hasB() const {
            return getNumFields() > 1;
        }
        
        /** returns the number of bits used by field b, assuming it is present */
        inline int getBNumBits() const {
            return fooBitOffset - bBitOffset;
        }
        
        /** returns the value of the field b at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getB(int index) const {
            const int bitOffset = bBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = fooBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bBitOffset);
        }
        
        /** returns the value of the field b at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBOrDefault(int index, int defaultValue = 0) const {
            return hasB() ? getB(index) : defaultValue;
        }    
        
        /** returns the bit offset of field foo at the given index, assuming it is present */
        inline int getFooBitOffset(int index) const {
            return fooBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field foo at the given index, assuming it is present */
        inline int hasFoo() const {
            return getNumFields() > 2;
        }
        
        /** returns the number of bits used by field foo, assuming it is present */
        inline int getFooNumBits() const {
            return endOffset - fooBitOffset;
        }
        
        /** returns the value of the field foo at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getFoo(int index) const {
            const int bitOffset = fooBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-fooBitOffset);
        }
        
        /** returns the value of the field foo at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getFooOrDefault(int index, int defaultValue = 0) const {
            return hasFoo() ? getFoo(index) : defaultValue;
        }
    } ABFooBitArray;
    
    
    typedef struct __attribute__((packed)) testStruct40 {
        ABFooBitArray bitArray;
    } testStruct40;
    
    
    typedef struct __attribute__((packed)) VarBitArrayA {
        uint16_t bitFieldArrayEntryBits;
        uint16_t aBitOffset;
        uint16_t bBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int getABitOffset(int index) const {
            return aBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int hasA() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field a, assuming it is present */
        inline int getANumBits() const {
            return bBitOffset - aBitOffset;
        }
        
        /** returns the value of the field a at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getA(int index) const {
            const int bitOffset = aBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = bBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-aBitOffset);
        }
        
        /** returns the value of the field a at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getAOrDefault(int index, int defaultValue = 0) const {
            return hasA() ? getA(index) : defaultValue;
        }    
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int getBBitOffset(int index) const {
            return bBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int hasB() const {
            return getNumFields() > 1;
        }
        
        /** returns the number of bits used by field b, assuming it is present */
        inline int getBNumBits() const {
            return endOffset - bBitOffset;
        }
        
        /** returns the value of the field b at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getB(int index) const {
            const int bitOffset = bBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bBitOffset);
        }
        
        /** returns the value of the field b at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBOrDefault(int index, int defaultValue = 0) const {
            return hasB() ? getB(index) : defaultValue;
        }
    } VarBitArrayA;
    
    
    typedef struct __attribute__((packed)) testStruct41A {
        VarBitArrayA bitArray;
    } testStruct41A;
    
    
    typedef struct __attribute__((packed)) VarBitArrayB {
        uint16_t bitFieldArrayEntryBits;
        uint16_t aBitOffset;
        uint16_t bBitOffset;
        uint16_t cBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int getABitOffset(int index) const {
            return aBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int hasA() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field a, assuming it is present */
        inline int getANumBits() const {
            return bBitOffset - aBitOffset;
        }
        
        /** returns the value of the field a at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getA(int index) const {
            const int bitOffset = aBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = bBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-aBitOffset);
        }
        
        /** returns the value of the field a at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getAOrDefault(int index, int defaultValue = 0) const {
            return hasA() ? getA(index) : defaultValue;
        }    
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int getBBitOffset(int index) const {
            return bBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int hasB() const {
            return getNumFields() > 1;
        }
        
        /** returns the number of bits used by field b, assuming it is present */
        inline int getBNumBits() const {
            return cBitOffset - bBitOffset;
        }
        
        /** returns the value of the field b at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getB(int index) const {
            const int bitOffset = bBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = cBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bBitOffset);
        }
        
        /** returns the value of the field b at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBOrDefault(int index, int defaultValue = 0) const {
            return hasB() ? getB(index) : defaultValue;
        }    
        
        /** returns the bit offset of field c at the given index, assuming it is present */
        inline int getCBitOffset(int index) const {
            return cBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field c at the given index, assuming it is present */
        inline int hasC() const {
            return getNumFields() > 2;
        }
        
        /** returns the number of bits used by field c, assuming it is present */
        inline int getCNumBits() const {
            return endOffset - cBitOffset;
        }
        
        /** returns the value of the field c at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getC(int index) const {
            const int bitOffset = cBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-cBitOffset);
        }
        
        /** returns the value of the field c at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getCOrDefault(int index, int defaultValue = 0) const {
            return hasC() ? getC(index) : defaultValue;
        }
    } VarBitArrayB;
    
    
    typedef struct __attribute__((packed)) testStruct41B {
        VarBitArrayB bitArray;
    } testStruct41B;
    
    
    typedef struct __attribute__((packed)) VarBitArrayC {
        uint16_t bitFieldArrayEntryBits;
        uint16_t aBitOffset;
        uint16_t bBitOffset;
        uint16_t cBitOffset;
        uint16_t dBitOffset;
        uint16_t endOffset;    
        
        /** returns the number of fields stored in this. Incoming data may have fewer
            or more than the defined number of fields, in which case it's still valid to
            access members, but only where fieldIndex < numFields. */
        inline int getNumFields() const {
            return ((((uint16_t*)(this))[1]) >> 4) - 2;
        }
        
        /** returns the bit offset of field with the given index at the given element index */
        inline int getBitOffsetByFieldIndex(int fieldIndex, int elementIndex) const {
            return ((uint16_t*)(this))[1+fieldIndex] + elementIndex*bitFieldArrayEntryBits;
        }
        
        
        /** returns the number of bits used by the field with the given field index. */
        inline int getNumBitsByFieldIndex(int fieldIndex) const {
            return ((uint16_t*)(this))[2+fieldIndex] - ((uint16_t*)(this))[1+fieldIndex];
        }
        
        /** returns the value of a field with given field index at the given element index, assuming it has <=31 bits. */
        inline uint32_t getByFieldIndex(int fieldIndex, int elementIndex) const {
            const int thisBitOffset = ((uint16_t*)(this))[1+fieldIndex];
            const int nextBitOffset = ((uint16_t*)(this))[2+fieldIndex];
            const int bitOffset = thisBitOffset + elementIndex*bitFieldArrayEntryBits;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-thisBitOffset);
        }    
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int getABitOffset(int index) const {
            return aBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field a at the given index, assuming it is present */
        inline int hasA() const {
            return getNumFields() > 0;
        }
        
        /** returns the number of bits used by field a, assuming it is present */
        inline int getANumBits() const {
            return bBitOffset - aBitOffset;
        }
        
        /** returns the value of the field a at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getA(int index) const {
            const int bitOffset = aBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = bBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-aBitOffset);
        }
        
        /** returns the value of the field a at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getAOrDefault(int index, int defaultValue = 0) const {
            return hasA() ? getA(index) : defaultValue;
        }    
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int getBBitOffset(int index) const {
            return bBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field b at the given index, assuming it is present */
        inline int hasB() const {
            return getNumFields() > 1;
        }
        
        /** returns the number of bits used by field b, assuming it is present */
        inline int getBNumBits() const {
            return cBitOffset - bBitOffset;
        }
        
        /** returns the value of the field b at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getB(int index) const {
            const int bitOffset = bBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = cBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-bBitOffset);
        }
        
        /** returns the value of the field b at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getBOrDefault(int index, int defaultValue = 0) const {
            return hasB() ? getB(index) : defaultValue;
        }    
        
        /** returns the bit offset of field c at the given index, assuming it is present */
        inline int getCBitOffset(int index) const {
            return cBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field c at the given index, assuming it is present */
        inline int hasC() const {
            return getNumFields() > 2;
        }
        
        /** returns the number of bits used by field c, assuming it is present */
        inline int getCNumBits() const {
            return dBitOffset - cBitOffset;
        }
        
        /** returns the value of the field c at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getC(int index) const {
            const int bitOffset = cBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = dBitOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-cBitOffset);
        }
        
        /** returns the value of the field c at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getCOrDefault(int index, int defaultValue = 0) const {
            return hasC() ? getC(index) : defaultValue;
        }    
        
        /** returns the bit offset of field d at the given index, assuming it is present */
        inline int getDBitOffset(int index) const {
            return dBitOffset + index*bitFieldArrayEntryBits;
        }
        
        /** returns the bit offset of field d at the given index, assuming it is present */
        inline int hasD() const {
            return getNumFields() > 3;
        }
        
        /** returns the number of bits used by field d, assuming it is present */
        inline int getDNumBits() const {
            return endOffset - dBitOffset;
        }
        
        /** returns the value of the field d at the given index, assuming it is present, and assuming it has <=31 bits */
        inline uint32_t getD(int index) const {
            const int bitOffset = dBitOffset + index*bitFieldArrayEntryBits;
            const int nextBitOffset = endOffset;
            return namedstruct::readBits(this, bitOffset, nextBitOffset-dBitOffset);
        }
        
        /** returns the value of the field d at the given index, assuming it has <= 31 bits, or the default the field is not present. */
        inline uint32_t getDOrDefault(int index, int defaultValue = 0) const {
            return hasD() ? getD(index) : defaultValue;
        }
    } VarBitArrayC;
    
    
    typedef struct __attribute__((packed)) testStruct41C {
        VarBitArrayC bitArray;
    } testStruct41C;
    
    
    enum class GenderEnum : uint8_t {
        FEMALE = 1,
        MALE = 0,
        OTHER = 2
    };
    
    
    enum class PartyEnum : int32_t {
        CONSERVATIVE = -1,
        GREEN = -4,
        LIBERAL = -2,
        NDP = -3
    };
    
    
    enum class NationEnum : char {
        ENGLISH = 'e',
        FRENCH = 'f',
        OTHER = 'a'
    };
    
    
    typedef struct __attribute__((packed)) testStruct42 {
        uint8_t genderEnumValue;
        int8_t  paddingByte0;
        int8_t  paddingByte1;
        int8_t  paddingByte2;
        int32_t partyEnumValue;
        char    nationEnumValue;
    
        /** Returns gender as a GenderEnum enum */
        inline GenderEnum getGender() const {
            return static_cast<GenderEnum>(this->genderEnumValue);
        }
        
        /** Returns party as a PartyEnum enum */
        inline PartyEnum getParty() const {
            return static_cast<PartyEnum>(this->partyEnumValue);
        }
        
        /** Returns nation as a NationEnum enum */
        inline NationEnum getNation() const {
            return static_cast<NationEnum>(this->nationEnumValue);
        }
        
                    bool operator==(const testStruct42& other) const {
                        return (    genderEnumValue == other.genderEnumValue
                    and paddingByte0 == other.paddingByte0
                    and paddingByte1 == other.paddingByte1
                    and paddingByte2 == other.paddingByte2
                    and partyEnumValue == other.partyEnumValue
                    and nationEnumValue == other.nationEnumValue);
                    }
                    
                    bool operator!=(const testStruct42& other) const {
                        return not (*this == other);
                    }
                } testStruct42;
    
    
    typedef struct __attribute__((packed)) bitField43 {
        uint16_t bits;
        /**  2 bits */ inline int getS1()    const { auto v = (bits >>  0) & 0x03;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        /**  2 bits */ inline int getS2()    const { auto v = (bits >>  2) & 0x03;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        /**  8 bits */ inline int getS3()    const { auto v = (bits >>  4) & 0xff;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        /**  0 bits */ inline int getEmpty() const { auto v =                   0;  return static_cast<int>(v); }
        
        inline void setS1(int v) {
            int16_t  intValue = static_cast<int16_t >(v);
            uint16_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0x03 <<  0)) | ((bitValue & 0x03) <<  0);
        }
        
        inline void setS2(int v) {
            int16_t  intValue = static_cast<int16_t >(v);
            uint16_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0x03 <<  2)) | ((bitValue & 0x03) <<  2);
        }
        
        inline void setS3(int v) {
            int16_t  intValue = static_cast<int16_t >(v);
            uint16_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0xff <<  4)) | ((bitValue & 0xff) <<  4);
        }
        
        inline void setEmpty(int v) {
            uint16_t intValue = static_cast<uint16_t>(v);
            uint16_t bitValue = intValue;
            bits = (bits & ~(0x00 << 12)) | ((bitValue & 0x00) << 12);
        }
        
        inline bool operator==(const bitField43 other) const {
            return (bits & 0xFFF) == (other.bits & 0xFFF);
        }
        
        inline bool operator!=(const bitField43 other) const {
            return not (*this == other);
        }
    } bitField43;
    
    
    
    typedef struct __attribute__((packed)) testStruct43 {
        bitField43 bitfield;
        
                    bool operator==(const testStruct43& other) const {
                        return bitfield == other.bitfield;
                    }
                    
                    bool operator!=(const testStruct43& other) const {
                        return not (*this == other);
                    }
                } testStruct43;
    
    
    typedef struct __attribute__((packed)) BitField44 {
        uint32_t bits;
        /** 32 bits */ inline int getField() const { auto v = (bits >>  0) & 0xffffffff;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        
        inline void setField(int v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0xffffffff <<  0)) | ((bitValue & 0xffffffff) <<  0);
        }
        
        inline bool operator==(const BitField44 other) const {
            return (bits & 0xFFFFFFFF) == (other.bits & 0xFFFFFFFF);
        }
        
        inline bool operator!=(const BitField44 other) const {
            return not (*this == other);
        }
    } BitField44;
    
    
    
    typedef struct __attribute__((packed)) testStruct44 {
        BitField44 bitfield;
        
                    bool operator==(const testStruct44& other) const {
                        return bitfield == other.bitfield;
                    }
                    
                    bool operator!=(const testStruct44& other) const {
                        return not (*this == other);
                    }
                } testStruct44;
    
    
    enum class YesEnum : uint16_t {
        yes = 0
    };
    
    
    enum class NoEnum : int32_t {
        no = -1
    };
    
    
    typedef struct __attribute__((packed)) BitField45 {
        uint32_t bits;
        /**  2 bits */ inline GenderEnum getGender() const { auto v = (bits >>  0) & 0x3;  return static_cast<GenderEnum>(v); }
        /**  3 bits */ inline PartyEnum getParty()   const { auto v = (bits >>  2) & 0x7;  return static_cast<PartyEnum>((v >> 1) ^ (-(v & 1))); }
        /**  0 bits */ inline YesEnum getYes()       const { auto v =                  0;  return static_cast<YesEnum>(v); }
        /**  1 bit  */ inline NoEnum getNo()         const { auto v = (bits >>  5) & 0x1;  return static_cast<NoEnum>((v >> 1) ^ (-(v & 1))); }
        /**  0 bits */ inline int getSignedEmpty()   const { auto v =                  0;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        /**  1 bit  */ inline int getOther()         const { auto v = (bits >>  6) & 0x1;  return static_cast<int>(v); }
        
        inline void setGender(GenderEnum v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x3 <<  0)) | ((bitValue & 0x3) <<  0);
        }
        
        inline void setParty(PartyEnum v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0x7 <<  2)) | ((bitValue & 0x7) <<  2);
        }
        
        inline void setYes(YesEnum v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x0 <<  5)) | ((bitValue & 0x0) <<  5);
        }
        
        inline void setNo(NoEnum v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0x1 <<  5)) | ((bitValue & 0x1) <<  5);
        }
        
        inline void setSignedEmpty(int v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0x0 <<  6)) | ((bitValue & 0x0) <<  6);
        }
        
        inline void setOther(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x1 <<  6)) | ((bitValue & 0x1) <<  6);
        }
        
        inline bool operator==(const BitField45 other) const {
            return (bits & 0x7F) == (other.bits & 0x7F);
        }
        
        inline bool operator!=(const BitField45 other) const {
            return not (*this == other);
        }
    } BitField45;
    
    
    
    typedef struct __attribute__((packed)) testStruct45 {
        BitField45 bitfield;
        
                    bool operator==(const testStruct45& other) const {
                        return bitfield == other.bitfield;
                    }
                    
                    bool operator!=(const testStruct45& other) const {
                        return not (*this == other);
                    }
                } testStruct45;
    
    
    typedef struct __attribute__((packed)) BitField46 {
        uint32_t bits;
        /**  3 bits */ inline int getA() const { auto v = (bits >>  0) & 0x7;  return static_cast<int>(v); }
        /**  4 bits */ inline int getB() const { auto v = (bits >>  3) & 0xf;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        /**  4 bits */ inline int getC() const { auto v = (bits >>  7) & 0xf;  return static_cast<int>(v); }
        /**  4 bits */ inline int getD() const { auto v = (bits >> 11) & 0xf;  return static_cast<int>(v); }
        
        inline void setA(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0x7 <<  0)) | ((bitValue & 0x7) <<  0);
        }
        
        inline void setB(int v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0xf <<  3)) | ((bitValue & 0xf) <<  3);
        }
        
        inline void setC(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0xf <<  7)) | ((bitValue & 0xf) <<  7);
        }
        
        inline void setD(int v) {
            uint32_t intValue = static_cast<uint32_t>(v);
            uint32_t bitValue = intValue;
            bits = (bits & ~(0xf << 11)) | ((bitValue & 0xf) << 11);
        }
        
        inline bool operator==(const BitField46 other) const {
            return (bits & 0x7FFF) == (other.bits & 0x7FFF);
        }
        
        inline bool operator!=(const BitField46 other) const {
            return not (*this == other);
        }
    } BitField46;
    
    
    
    typedef struct __attribute__((packed)) testStruct46 {
        BitField46 bitfield;
        
                    bool operator==(const testStruct46& other) const {
                        return bitfield == other.bitfield;
                    }
                    
                    bool operator!=(const testStruct46& other) const {
                        return not (*this == other);
                    }
                } testStruct46;
    
    
    typedef struct __attribute__((packed)) BitField47 {
        uint32_t bits;
        /** 32 bits */ inline int getNumber() const { auto v = (bits >>  0) & 0xffffffff;  return static_cast<int>((v >> 1) ^ (-(v & 1))); }
        
        inline void setNumber(int v) {
            int32_t  intValue = static_cast<int32_t >(v);
            uint32_t bitValue = namedstruct::zigZagEncode(intValue);
            bits = (bits & ~(0xffffffff <<  0)) | ((bitValue & 0xffffffff) <<  0);
        }
        
        inline bool operator==(const BitField47 other) const {
            return (bits & 0xFFFFFFFF) == (other.bits & 0xFFFFFFFF);
        }
        
        inline bool operator!=(const BitField47 other) const {
            return not (*this == other);
        }
    } BitField47;
    
    
    
    typedef struct __attribute__((packed)) testStruct47 {
        BitField47 bitfield;
        
                    bool operator==(const testStruct47& other) const {
                        return bitfield == other.bitfield;
                    }
                    
                    bool operator!=(const testStruct47& other) const {
                        return not (*this == other);
                    }
                } testStruct47;
    
    
    typedef struct __attribute__((packed)) Aardvark {
        uint8_t weight;
        
                    bool operator==(const Aardvark& other) const {
                        return weight == other.weight;
                    }
                    
                    bool operator!=(const Aardvark& other) const {
                        return not (*this == other);
                    }
                } Aardvark;
    
    
    typedef struct __attribute__((packed)) Wombat {
        int8_t isABat;
        
                    bool operator==(const Wombat& other) const {
                        return isABat == other.isABat;
                    }
                    
                    bool operator!=(const Wombat& other) const {
                        return not (*this == other);
                    }
                } Wombat;
    
    
    typedef struct __attribute__((packed)) Zebra {
        uint8_t stripes;
        
                    bool operator==(const Zebra& other) const {
                        return stripes == other.stripes;
                    }
                    
                    bool operator!=(const Zebra& other) const {
                        return not (*this == other);
                    }
                } Zebra;
    
    
    typedef struct __attribute__((packed)) SubWalrus {
        uint64_t hugeNumber;
        
                    bool operator==(const SubWalrus& other) const {
                        return hugeNumber == other.hugeNumber;
                    }
                    
                    bool operator!=(const SubWalrus& other) const {
                        return not (*this == other);
                    }
                } SubWalrus;
    
    
    typedef struct __attribute__((packed)) Walrus {
        int32_t subWalrusByteOffset;
    
        /** Returns SubWalrus-pointer to member subWalrus.
         *  If subWalrus is null/void then the result is undefined. */
        inline SubWalrus* getSubWalrus() const {
            return (SubWalrus*)(uintptr_t(this)+this->subWalrusByteOffset);
        }
    } Walrus;
    
    
    typedef struct __attribute__((packed)) Baboon {
        uint8_t something;
        
                    bool operator==(const Baboon& other) const {
                        return something == other.something;
                    }
                    
                    bool operator!=(const Baboon& other) const {
                        return not (*this == other);
                    }
                } Baboon;
    
    
    typedef struct __attribute__((packed)) testPackOrder {
        int32_t aardvarkByteOffset;
        int32_t wombatByteOffset;
        int32_t zebraByteOffset;
        int32_t walrusByteOffset;
        int32_t baboonByteOffset;
    
        /** Returns Aardvark-pointer to member aardvark.
         *  If aardvark is null/void then the result is undefined. */
        inline Aardvark* getAardvark() const {
            return (Aardvark*)(uintptr_t(this)+this->aardvarkByteOffset);
        }
        
        /** Returns Wombat-pointer to member wombat.
         *  If wombat is null/void then the result is undefined. */
        inline Wombat* getWombat() const {
            return (Wombat*)(uintptr_t(this)+this->wombatByteOffset);
        }
        
        /** Returns Zebra-pointer to member zebra.
         *  If zebra is null/void then the result is undefined. */
        inline Zebra* getZebra() const {
            return (Zebra*)(uintptr_t(this)+this->zebraByteOffset);
        }
        
        /** Returns Walrus-pointer to member walrus.
         *  If walrus is null/void then the result is undefined. */
        inline Walrus* getWalrus() const {
            return (Walrus*)(uintptr_t(this)+this->walrusByteOffset);
        }
        
        /** Returns Baboon-pointer to member baboon.
         *  If baboon is null/void then the result is undefined. */
        inline Baboon* getBaboon() const {
            return (Baboon*)(uintptr_t(this)+this->baboonByteOffset);
        }
    } testPackOrder;
    
    
    typedef struct __attribute__((packed)) testMatrix {
        int32_t fixedMatrix[3][2];
        int32_t extraValueByteOffset;
    
        /** Returns char-pointer to member extraValue.
         *  If extraValue is null/void then the result is undefined. */
        inline char* getExtraValue() const {
            return (char*)(uintptr_t(this)+this->extraValueByteOffset);
        }
    } testMatrix;
    
    
}
#endif /* defined(__NAMEDSTRUCTTEST__) */
